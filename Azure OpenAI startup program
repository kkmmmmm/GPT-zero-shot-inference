#!/usr/bin/env python
# -*- coding: utf-8 -*-
r"""
run_prompts_via_proxy_no_verify_gpt5_responses_strict_reasoning.py
- UNC ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—ã® prompts.csv / .xlsx ã‚’èª­ã¿è¾¼ã¿
- ãƒ—ãƒ­ã‚­ã‚·çµŒç”±ãƒ»SSLæ¤œè¨¼ã‚ªãƒ•ã§ Azure OpenAI (GPT-5, Responses API, api-version=preview) ã‚’å‘¼ã³å‡ºã—
- çµæœã‚’ prompts_results.xlsx ã¨ã—ã¦ä¿å­˜
- reasoning ã¯æŒ‡å®šå€¤ã‚’å³æ ¼ã«ä½¿ç”¨ï¼ˆè‡ªå‹•ãƒ€ã‚¦ãƒ³ã‚°ãƒ¬ãƒ¼ãƒ‰ç„¡ã—ï¼‰
- ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã¯ 240s
- verbosity ã¯å¸¸ã« low
"""

import os
import sys
import time
from pathlib import Path
from typing import List, Dict, Optional

import pandas as pd
import httpx
from dotenv import load_dotenv
from openai import AzureOpenAI

# --- ãƒªãƒˆãƒ©ã‚¤å¯¾è±¡ä¾‹å¤–ï¼ˆSDKå·®åˆ†ã‚’å¸åï¼‰ -------------------------------------
try:
    from openai import error as _openai_error  # v0ç³»
    RETRY_ERRORS = (_openai_error.Timeout, _openai_error.APIError, _openai_error.RateLimitError)
except Exception:
    try:
        from openai import APIError, RateLimitError, APITimeoutError  # v1ç³»
        RETRY_ERRORS = (APITimeoutError, APIError, RateLimitError)
    except Exception:
        RETRY_ERRORS = (Exception,)
# ---------------------------------------------------------------------------

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ãƒ¦ãƒ¼ã‚¶è¨­å®š â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ #
DESKTOP_DIR: Path        = Path(r"\\FRedirect\desktop$\mk07637")
DEFAULT_INPUT_FILE: str  = "prompts.csv"     # .csv / .xlsx ä¸¡å¯¾å¿œ
OUTPUT_FILE_NAME: str    = "prompts_results.xlsx"
MAX_RETRIES: int         = 3
WAIT_SEC: int            = 2
FALLBACK_TEXT: str       = "I do not know"

# reasoning ã‚’å›ºå®šï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã—ãªã„ï¼‰
STRICT_REASONING: bool   = True
REASONING_EFFORT: str    = "high"            # â† ã“ã“ã‚’ "low" / "medium" ç­‰ã«å¤‰æ›´å¯

# ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã¯ 60s â†’ 240sï¼ˆ4å€ï¼‰
HTTP_TIMEOUT_SEC: float  = 240.0
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ #

# 1) .envï¼ˆ4é …ç›®ã ã‘ã§OKï¼‰
load_dotenv(override=True)
api_key     = os.getenv("OPENAI_API_KEY")
endpoint    = os.getenv("AZURE_OPENAI_ENDPOINT")  # ä¾‹: https://<resource>.cognitiveservices.azure.com
deployment  = os.getenv("OPENAI_DEPLOYMENT_NAME", "gpt-5")
if not api_key or not endpoint:
    raise RuntimeError("âŒ OPENAI_API_KEY / AZURE_OPENAI_ENDPOINT ãŒæœªè¨­å®šã§ã™ã€‚")

# 2) ãƒ—ãƒ­ã‚­ã‚·ï¼ˆæœªè¨­å®šãªã‚‰ãƒ­ãƒ¼ã‚«ãƒ«æ—¢å®šï¼‰
os.environ.setdefault("HTTP_PROXY",  os.getenv("HTTP_PROXY",  "http://localhost:3128"))
os.environ.setdefault("HTTPS_PROXY", os.getenv("HTTPS_PROXY", "http://localhost:3128"))

# 3) httpx ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆï¼ˆSSLæ¤œè¨¼ã‚ªãƒ•ãƒ»ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ 240sï¼‰
http_client = httpx.Client(
    verify=False,             # â† é–‹ç™ºç”¨é€”ã®ã¿
    timeout=HTTP_TIMEOUT_SEC,
    trust_env=True,
)

# 4) Azure OpenAI ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆï¼ˆResponses API ã¯ /openai/v1/ & api-version=previewï¼‰
client = AzureOpenAI(
    api_key=api_key,
    base_url=f"{endpoint}/openai/v1/",
    api_version="preview",
    http_client=http_client,
)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ é–¢æ•°å®šç¾© â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ #

def load_prompts(path: Path) -> List[str]:
    if not path.exists():
        raise FileNotFoundError(f"âŒ Prompt file not found: {path}")
    df = pd.read_csv(path) if path.suffix.lower() == ".csv" else pd.read_excel(path)
    series = df["prompt"] if "prompt" in df.columns else df.iloc[:, 0]
    return series.astype(str).tolist()

def _extract_text_from_response(resp) -> str:
    text = getattr(resp, "output_text", None)
    if text:
        return text.strip()
    try:
        parts = []
        for item in getattr(resp, "output", []) or []:
            for c in getattr(item, "content", []) or []:
                if getattr(c, "type", "") in ("output_text", "text"):
                    t = getattr(c, "text", "")
                    if t:
                        parts.append(t)
        text = "".join(parts).strip()
        if text:
            return text
    except Exception:
        pass
    return ""

def chat_once(prompt: str) -> (str, Optional[str]):
    """
    Responses API ã« 1 å›å•ã„åˆã‚ã›ã¦ (å¿œç­”æ–‡å­—åˆ—, ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸) ã‚’è¿”ã™ã€‚
    reasoning ã¯ STRICT ã«å›ºå®šã€‚æœªå¯¾å¿œã§ã‚‚ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã—ãªã„ã€‚
    verbosity ã¯å¸¸ã« low ã‚’é€ä¿¡ã€‚
    """
    instructions = "Answer concisely. Do not include chain-of-thought."

    for attempt in range(1, MAX_RETRIES + 1):
        try:
            kwargs = dict(
                model=deployment,
                input=prompt,
                instructions=instructions,
                # â–¼ è¿½åŠ ï¼šverbosity ã‚’ä½å†—é•·ã«å›ºå®š
                text={"verbosity": "low"},
            )
            if STRICT_REASONING:
                kwargs["reasoning"] = {"effort": REASONING_EFFORT}

            resp = client.responses.create(**kwargs)
            text = _extract_text_from_response(resp)
            return (text if text else FALLBACK_TEXT, None)

        except RETRY_ERRORS as exc:
            msg = str(exc)
            if "not supported" in msg.lower() or "unknown parameter" in msg.lower():
                return (FALLBACK_TEXT, f"request failed (reasoning='{REASONING_EFFORT}', verbosity='low'): {msg}")
            if attempt == MAX_RETRIES:
                return (FALLBACK_TEXT, f"request failed after retries (reasoning='{REASONING_EFFORT}', verbosity='low'): {msg}")
            backoff = WAIT_SEC * attempt
            print(f"[Retry {attempt}/{MAX_RETRIES}] {exc} â†’ wait {backoff}s", file=sys.stderr)
            time.sleep(backoff)

        except Exception as exc:
            msg = str(exc)
            return (FALLBACK_TEXT, f"unexpected error (reasoning='{REASONING_EFFORT}', verbosity='low'): {msg}")

def save_results(results: List[Dict[str, str]], path: Path) -> None:
    if not results:
        print("âš ï¸  ä¿å­˜å¯¾è±¡ãŒç©ºã®ãŸã‚ã‚¹ã‚­ãƒƒãƒ—", file=sys.stderr)
        return
    try:
        with pd.ExcelWriter(path, engine="xlsxwriter") as w:
            pd.DataFrame(results).to_excel(w, index=False, sheet_name="results")
        print(f"âœ… Results saved: {path}")
    except Exception as exc:
        print(f"âŒ Failed to save results: {exc}", file=sys.stderr)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ãƒ¡ã‚¤ãƒ³ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ #

def main() -> None:
    input_path  = DESKTOP_DIR / DEFAULT_INPUT_FILE
    output_path = DESKTOP_DIR / OUTPUT_FILE_NAME

    print(f"ğŸ“¥ Loading prompts from: {input_path}")
    prompts = load_prompts(input_path)
    print(f"âœ… {len(prompts)} prompts loaded")

    results: List[Dict[str, str]] = []
    try:
        for i, p in enumerate(prompts, 1):
            print(f"[{i}/{len(prompts)}] queryingâ€¦")
            ans, err = chat_once(p)
            row = {
                "prompt": p,
                "response": ans,
                "reasoning_effort": REASONING_EFFORT if STRICT_REASONING else "",
                "error": err or "",
            }
            results.append(row)
    finally:
        print(f"ğŸ’¾ Saving â†’ {output_path}")
        save_results(results, output_path)
    print("ğŸ‰ All done!")

if __name__ == "__main__":
    main()
